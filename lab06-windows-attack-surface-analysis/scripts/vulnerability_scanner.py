#!/usr/bin/env python3
import subprocess
import re
import json
from datetime import datetime
from colorama import init, Fore, Style

init(autoreset=True)

class VulnerabilityScanner:
    def __init__(self):
        self.scan_results = {
            "timestamp": datetime.now().isoformat(),
            "scanned_components": [],
            "vulnerabilities": [],
            "recommendations": []
        }

    def _add_vuln(self, component, name, severity, description, evidence=""):
        self.scan_results["vulnerabilities"].append({
            "component": component,
            "name": name,
            "severity": severity,
            "description": description,
            "evidence": evidence
        })

    def scan_ssh_configuration(self):
        """
        Scan SSH configuration for security issues.
        """
        component = "SSH"
        self.scan_results["scanned_components"].append("SSH Configuration (/etc/ssh/sshd_config)")

        path = "/etc/ssh/sshd_config"
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()
        except PermissionError:
            self._add_vuln(
                component,
                "Unable to Read SSH Config",
                "LOW",
                "Permission denied reading /etc/ssh/sshd_config. Run with sudo for full results.",
                "PermissionError"
            )
            return
        except FileNotFoundError:
            self._add_vuln(
                component,
                "SSH Config Not Found",
                "LOW",
                "File /etc/ssh/sshd_config not found (sshd may not be installed).",
                ""
            )
            return

        effective = {}
        for line in lines:
            s = line.strip()
            if not s or s.startswith("#"):
                continue
            parts = s.split()
            if len(parts) >= 2:
                key = parts[0].strip()
                val = parts[1].strip()
                effective[key.lower()] = val

        prl = effective.get("permitrootlogin", None)
        pa = effective.get("passwordauthentication", None)

        if prl is None:
            self._add_vuln(
                component,
                "PermitRootLogin Not Explicitly Set",
                "LOW",
                "PermitRootLogin is not explicitly set. Verify effective config using 'sshd -T'.",
                "No PermitRootLogin directive found"
            )
        else:
            if prl.lower() in ("yes", "without-password", "prohibit-password"):
                sev = "HIGH" if prl.lower() == "yes" else "MEDIUM"
                self._add_vuln(
                    component,
                    "PermitRootLogin Enabled",
                    sev,
                    f"PermitRootLogin is set to '{prl}'. Direct root SSH login increases risk.",
                    f"PermitRootLogin {prl}"
                )

        if pa is None:
            self._add_vuln(
                component,
                "PasswordAuthentication Not Explicitly Set",
                "LOW",
                "PasswordAuthentication not explicitly set. Verify effective config using 'sshd -T'.",
                "No PasswordAuthentication directive found"
            )
        else:
            if pa.lower() == "yes":
                self._add_vuln(
                    component,
                    "PasswordAuthentication Enabled",
                    "MEDIUM",
                    "PasswordAuthentication is enabled. Consider disabling and using SSH keys only.",
                    f"PasswordAuthentication {pa}"
                )

    def scan_network_services(self):
        """
        Scan network services for common vulnerabilities.
        """
        component = "Network Services"
        self.scan_results["scanned_components"].append("Listening Network Services (ss/netstat)")

        try:
            p = subprocess.run(["ss", "-tlnp"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            out = p.stdout
            if p.returncode != 0 or not out.strip():
                raise RuntimeError("ss failed")
            lines = out.splitlines()
            parser = "ss"
        except Exception:
            p = subprocess.run(["netstat", "-tlnp"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            out = p.stdout
            lines = out.splitlines()
            parser = "netstat"

        listeners = []

        if parser == "ss":
            for line in lines:
                if line.startswith("State") or line.startswith("Netid"):
                    continue
                parts = line.split()
                if len(parts) < 5:
                    continue
                local = parts[3]
                port = None
                if ":" in local:
                    port_str = local.rsplit(":", 1)[-1].strip("[]")
                    if port_str.isdigit():
                        port = int(port_str)
                proc_info = ""
                if "users:(" in line:
                    proc_info = line.split("users:(", 1)[1].rstrip(")")
                if port is not None:
                    listeners.append((port, local, proc_info))
        else:
            for line in lines:
                if line.startswith("Proto") or line.startswith("Active"):
                    continue
                parts = line.split()
                if len(parts) < 7:
                    continue
                proto = parts[0]
                local = parts[3]
                state = parts[5] if proto.startswith("tcp") else ""
                pidprog = parts[6] if len(parts) >= 7 else ""
                if proto.startswith("tcp") and state != "LISTEN":
                    continue
                port = None
                if ":" in local:
                    port_str = local.rsplit(":", 1)[-1]
                    if port_str.isdigit():
                        port = int(port_str)
                if port is not None:
                    listeners.append((port, local, pidprog))

        risky = {
            21: ("FTP Service Detected", "HIGH", "FTP is unencrypted. Replace with SFTP/FTPS."),
            23: ("Telnet Service Detected", "HIGH", "Telnet is unencrypted. Disable and use SSH."),
            80: ("HTTP Service Detected", "MEDIUM", "HTTP is plaintext. Ensure HTTPS is enforced."),
            139: ("NetBIOS Detected", "HIGH", "NetBIOS/SMB exposure can be high risk."),
            445: ("SMB Detected", "HIGH", "SMB exposure can be high risk; restrict access."),
            3306: ("MySQL Exposed", "HIGH", "Database port exposed. Restrict to internal network."),
            5432: ("PostgreSQL Exposed", "HIGH", "Database port exposed. Restrict to internal network."),
            1433: ("MSSQL Exposed", "HIGH", "Database port exposed. Restrict to internal network."),
            6379: ("Redis Exposed", "HIGH", "Redis exposed. Restrict access and require auth."),
            9200: ("Elasticsearch Exposed", "HIGH", "Elasticsearch exposed. Restrict access and secure cluster."),
            3389: ("RDP Port Exposed", "HIGH", "RDP exposure is high risk; restrict via VPN/allowlist."),
            5900: ("VNC Port Exposed", "HIGH", "VNC exposure is high risk; restrict/disable if not needed.")
        }

        for port, local, procinfo in listeners:
            if port in risky:
                name, sev, desc = risky[port]
                self._add_vuln(component, name, sev, desc, f"{local} | {procinfo}")

    def scan_file_permissions(self):
        """
        Scan for dangerous file permissions.
        """
        component = "File Permissions"
        self.scan_results["scanned_components"].append("File Permissions (world-writable, SUID/SGID)")

        try:
            cmd = ["bash", "-lc", "find /etc -xdev -type f -perm -0002 2>/dev/null | head -50"]
            p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            ww = [line.strip() for line in p.stdout.splitlines() if line.strip()]
            if ww:
                self._add_vuln(
                    component,
                    "World-writable files in /etc",
                    "HIGH",
                    "World-writable configuration files can allow privilege escalation or tampering.",
                    "\n".join(ww)
                )
        except Exception:
            pass

        try:
            cmd = ["bash", "-lc", "find /usr/bin /bin /usr/sbin /sbin -xdev -type f \\( -perm -4000 -o -perm -2000 \\) 2>/dev/null | head -80"]
            p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            suid = [line.strip() for line in p.stdout.splitlines() if line.strip()]
            if suid:
                self._add_vuln(
                    component,
                    "SUID/SGID binaries present",
                    "MEDIUM",
                    "SUID/SGID binaries increase privilege escalation risk. Review necessity and patch levels.",
                    "\n".join(suid)
                )
        except Exception:
            pass

        critical_files = ["/etc/passwd", "/etc/shadow", "/etc/sudoers"]
        for cf in critical_files:
            try:
                cmd = ["bash", "-lc", f"stat -c '%A %U:%G %n' {cf} 2>/dev/null"]
                p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                out = p.stdout.strip()
                if not out:
                    continue

                if cf == "/etc/shadow":
                    if "root:shadow" not in out:
                        self._add_vuln(
                            component,
                            "Weak /etc/shadow permissions",
                            "HIGH",
                            "/etc/shadow should be readable only by root/shadow group.",
                            out
                        )

                if cf == "/etc/sudoers":
                    if "root:root" not in out:
                        self._add_vuln(
                            component,
                            "sudoers not owned by root:root",
                            "HIGH",
                            "/etc/sudoers ownership should be root:root.",
                            out
                        )
                    perms = out.split()[0]
                    if len(perms) >= 9 and (perms[5] != "-" or perms[8] != "-"):
                        self._add_vuln(
                            component,
                            "sudoers permissions too permissive",
                            "HIGH",
                            "/etc/sudoers should not be writable by group/others.",
                            out
                        )
            except Exception:
                continue

    def generate_recommendations(self):
        """
        Generate security recommendations from findings.
        """
        vulns = self.scan_results.get("vulnerabilities", [])
        recs = []

        for v in vulns:
            sev = v.get("severity", "LOW").upper()
            name = v.get("name", "")
            comp = v.get("component", "")

            if "Telnet" in name:
                recs.append(("HIGH", "Disable Telnet and use SSH instead."))
            elif "FTP" in name:
                recs.append(("HIGH", "Disable FTP or migrate to SFTP/FTPS with strong authentication."))
            elif "Database port exposed" in v.get("description", "") or "Exposed" in name:
                recs.append(("HIGH", "Restrict database/service ports to internal networks or VPN/allowlist."))
            elif "PasswordAuthentication Enabled" in name:
                recs.append(("MEDIUM", "Disable SSH password auth and enforce key-based authentication."))
            elif "PermitRootLogin Enabled" in name:
                recs.append(("HIGH", "Disable root SSH login (PermitRootLogin no) and use sudo with MFA if possible."))
            elif "World-writable" in name:
                recs.append(("HIGH", "Remove world-writable permissions from sensitive configuration paths."))
            elif "SUID/SGID" in name:
                recs.append(("MEDIUM", "Review SUID/SGID binaries, remove unnecessary ones, and keep packages updated."))
            else:
                if sev == "HIGH":
                    recs.append(("HIGH", f"Investigate and remediate: {comp} - {name}"))
                elif sev == "MEDIUM":
                    recs.append(("MEDIUM", f"Review and harden: {comp} - {name}"))
                else:
                    recs.append(("LOW", f"Consider improvement: {comp} - {name}"))

        seen = set()
        final = []
        for sev, r in recs:
            key = (sev, r)
            if key not in seen:
                seen.add(key)
                final.append((sev, r))

        sev_rank = {"HIGH": 0, "MEDIUM": 1, "LOW": 2}
        final_sorted = sorted(final, key=lambda x: sev_rank.get(x[0], 3))

        self.scan_results["recommendations"] = [{"severity": s, "recommendation": r} for s, r in final_sorted]

    def display_results(self):
        """
        Print results to terminal.
        """
        print(f"{Fore.CYAN}{'='*70}")
        print(" VULNERABILITY SCANNER RESULTS")
        print(f"{'='*70}{Style.RESET_ALL}")

        print(f"{Fore.GREEN}[+] Timestamp:{Style.RESET_ALL} {self.scan_results.get('timestamp')}")
        print("")

        print(f"{Fore.YELLOW}Scanned Components{Style.RESET_ALL}")
        for c in self.scan_results.get("scanned_components", []):
            print(f"- {c}")

        vulns = self.scan_results.get("vulnerabilities", [])
        print("")
        print(f"{Fore.YELLOW}Vulnerabilities{Style.RESET_ALL}")
        if not vulns:
            print(f"{Fore.GREEN}- No vulnerabilities found by current checks.{Style.RESET_ALL}")
        else:
            def rank(sev):
                return {"HIGH": 0, "MEDIUM": 1, "LOW": 2}.get(sev.upper(), 3)

            vulns_sorted = sorted(vulns, key=lambda v: rank(v.get("severity", "LOW")))
            for v in vulns_sorted:
                sev = v.get("severity", "LOW").upper()
                color = Fore.RED if sev == "HIGH" else (Fore.YELLOW if sev == "MEDIUM" else Fore.WHITE)
                print(f"{color}- [{sev}] {v.get('component')}: {v.get('name')}{Style.RESET_ALL}")
                print(f"  Description: {v.get('description')}")
                ev = v.get("evidence", "").strip()
                if ev:
                    print("  Evidence:")
                    for line in ev.splitlines()[:20]:
                        print(f"    {line}")
                print("")

        print(f"{Fore.YELLOW}Recommendations{Style.RESET_ALL}")
        recs = self.scan_results.get("recommendations", [])
        if not recs:
            print(f"{Fore.GREEN}- No recommendations generated.{Style.RESET_ALL}")
        else:
            for r in recs:
                sev = r.get("severity", "LOW")
                color = Fore.RED if sev == "HIGH" else (Fore.YELLOW if sev == "MEDIUM" else Fore.WHITE)
                print(f"{color}- [{sev}] {r.get('recommendation')}{Style.RESET_ALL}")

    def save_report(self, filename="vulnerability_report.json"):
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(self.scan_results, f, indent=2)
        print(f"{Fore.GREEN}[+] Vulnerability report saved to {filename}{Style.RESET_ALL}")

def main():
    vs = VulnerabilityScanner()
    vs.scan_ssh_configuration()
    vs.scan_network_services()
    vs.scan_file_permissions()
    vs.generate_recommendations()
    vs.display_results()
    vs.save_report("vulnerability_report.json")

if __name__ == "__main__":
    main()
