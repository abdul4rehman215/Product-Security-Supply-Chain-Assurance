#!/usr/bin/env python3
from scapy.all import rdpcap, TCP, Raw
import math
import json
import struct
from datetime import datetime


class VulnerabilityScanner:
    def __init__(self, pcap_file):
        self.pcap_file = pcap_file
        self.vulnerabilities = []

    def calculate_entropy(self, data):
        """
        Calculate Shannon entropy to detect encryption.

        Count byte frequencies
        Calculate probability distribution
        Compute entropy: -sum(p * log2(p))
        Return entropy score (0-8)
        """
        if not data:
            return 0.0

        freq = {}
        for b in data:
            freq[b] = freq.get(b, 0) + 1

        length = len(data)
        entropy = 0.0
        for count in freq.values():
            p = count / length
            entropy -= p * math.log2(p)

        return entropy

    def check_information_disclosure(self, payload):
        """
        Search for sensitive keywords (password, secret, key, flag)
        Check for plaintext credentials
        Identify exposed internal data
        """
        findings = []
        lower = payload.lower()

        keywords = [b"password", b"secret", b"apikey", b"api_key", b"token", b"key", b"flag", b"credential"]
        for k in keywords:
            if k in lower:
                findings.append(f"Sensitive keyword found in plaintext: {k.decode(errors='ignore')}")
        return findings

    def check_weak_authentication(self, payload):
        """
        Identify predictable magic bytes
        Check for missing authentication fields
        Detect replay attack vulnerabilities
        """
        findings = []

        if len(payload) >= 4 and payload[:4] == b"CPRO":
            findings.append("Predictable fixed magic bytes 'CPRO' detected (easy fingerprinting).")

        # Our protocol has no auth fields by design
        findings.append("No authentication field present (unauthenticated message injection possible).")
        findings.append("Replay likely possible (no nonce/timestamp/sequence enforced by protocol).")

        return findings

    def check_integrity_protection(self, payload):
        """
        Analyze checksum strength
        Test for collision resistance
        Verify checksum validation
        """
        findings = []
        if len(payload) < 9:
            return findings

        try:
            # Parse: [4s][B][B][H]
            magic, version, msg_type, length = struct.unpack("!4sBBH", payload[:8])
            total_len = 8 + length + 1
            if len(payload) < total_len:
                return findings

            data = payload[8:8 + length]
            checksum = payload[8 + length]
            calc = sum(data) % 256

            if calc != checksum:
                findings.append("Checksum validation failed for observed payload (integrity not enforced consistently).")
            else:
                findings.append("Checksum is simple sum(data)%256 (weak; easy to forge; high collision risk).")

            findings.append("1-byte checksum has very low collision resistance (256 possible values).")
        except Exception:
            pass

        return findings

    def check_buffer_overflow_risk(self, payload):
        """
        Identify oversized payloads
        Check length field validation
        Detect potential buffer overflows
        """
        findings = []
        if len(payload) < 8:
            return findings

        # Oversized payload heuristic
        if len(payload) > 1500:
            findings.append(f"Oversized payload observed ({len(payload)} bytes) - potential parsing risk.")

        # Check length mismatch
        try:
            length = struct.unpack("!H", payload[6:8])[0]
            expected_total = 8 + length + 1
            if expected_total != len(payload):
                findings.append(
                    f"Length field mismatch: length={length}, expected_total={expected_total}, actual={len(payload)}"
                )
                findings.append("Length mismatch could indicate missing validation, raising overflow/DoS risk.")
        except Exception:
            pass

        return findings

    def load_payloads(self):
        pkts = rdpcap(self.pcap_file)
        payloads = []
        for p in pkts:
            if p.haslayer(TCP) and p.haslayer(Raw):
                data = bytes(p[Raw].load)
                if data:
                    payloads.append(data)
        return payloads

    def add_vuln(self, title, severity, details, evidence=None):
        self.vulnerabilities.append({
            "title": title,
            "severity": severity,
            "details": details,
            "evidence": evidence
        })

    def scan_all_vulnerabilities(self):
        """
        Load packets from PCAP
        Run all vulnerability checks
        Categorize by severity (Critical, High, Medium, Low)
        Generate vulnerability report
        """
        payloads = self.load_payloads()
        if not payloads:
            self.add_vuln(
                "No payloads found",
                "Low",
                "PCAP contained no TCP Raw payloads. Ensure capture was run correctly.",
                evidence=None
            )
            return

        # Entropy checks overall
        entropies = [self.calculate_entropy(p) for p in payloads]
        avg_entropy = sum(entropies) / len(entropies)

        if avg_entropy < 4.0:
            self.add_vuln(
                "Missing encryption (plaintext protocol)",
                "High",
                f"Average entropy is low ({avg_entropy:.2f}), suggesting plaintext traffic.",
                evidence=f"avg_entropy={avg_entropy:.2f}"
            )
        else:
            self.add_vuln(
                "Possibly encrypted or compressed traffic",
                "Low",
                f"Average entropy is moderate/high ({avg_entropy:.2f}).",
                evidence=f"avg_entropy={avg_entropy:.2f}"
            )

        # Per-payload checks
        for p in payloads:
            info = self.check_information_disclosure(p)
            if info:
                self.add_vuln(
                    "Information disclosure in plaintext",
                    "High",
                    "Sensitive keywords detected in protocol payload.",
                    evidence=info
                )

            auth = self.check_weak_authentication(p)
            if auth:
                self.add_vuln(
                    "Weak or missing authentication",
                    "High",
                    "Protocol appears to lack authentication, enabling injection/replay.",
                    evidence=auth
                )

            integ = self.check_integrity_protection(p)
            if integ:
                self.add_vuln(
                    "Weak integrity protection",
                    "Medium",
                    "Checksum is weak and easy to forge; low collision resistance.",
                    evidence=integ
                )

            bo = self.check_buffer_overflow_risk(p)
            if bo:
                self.add_vuln(
                    "Potential length/overflow risk",
                    "Medium",
                    "Length field mismatch or oversized payload suggests parsing risk.",
                    evidence=bo
                )

    def generate_report(self):
        """
        Create formatted vulnerability report
        Include remediation recommendations
        Save to file
        """
        report = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "pcap_file": self.pcap_file,
            "vulnerability_count": len(self.vulnerabilities),
            "vulnerabilities": self.vulnerabilities,
            "recommendations": [
                "Add authentication (HMAC or signatures) to prevent message injection and replay.",
                "Replace checksum with cryptographic integrity (HMAC-SHA256) and validate strictly.",
                "Encrypt payloads (TLS or application-layer encryption) to prevent disclosure.",
                "Validate length fields and implement strict bounds checking to prevent DoS/overflows.",
                "Add sequence numbers/nonces/timestamps to resist replay attacks."
            ]
        }

        with open("vulnerability_report.json", "w") as f:
            json.dump(report, f, indent=2)

        print("\n=== Vulnerability Report ===")
        print(f"Total vulnerabilities recorded: {report['vulnerability_count']}")
        print("[+] Saved vulnerability_report.json")


if __name__ == "__main__":
    scanner = VulnerabilityScanner("protocol_capture.pcap")
    scanner.scan_all_vulnerabilities()
    scanner.generate_report()
